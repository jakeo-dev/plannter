import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faPlus } from "@fortawesome/free-solid-svg-icons";
import { Dispatch, SetStateAction, useEffect, useState } from "react";

import { indexOfGreatestNumber, monthNumber } from "@/utility";
import { Test, Group } from "@/types";
import TestElem from "./TestElem";

function ListAttribute({
  name,
  calculation,
  decimals,
  classN,
}: {
  name: string;
  calculation: number;
  decimals: number;
  classN: string;
}) {
  if (!calculation) return <></>;

  return (
    <div
      className={`${classN} inline-flex text-sm text-left bg-gray-300 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-md break-words transition px-2 py-[0.075rem] mr-1 md:mr-2 mt-2`}
    >
      {calculation != -1 ? calculation.toFixed(decimals) : ""} {name}
    </div>
  );
}

function sortTests(a: Test, b: Test) {
  const getTypeLevel = (type: string) => {
    if (type == "ACT") return 6;
    else if (type == "SAT") return 5;
    else if (type == "PreACT") return 4;
    else if (type == "PSAT") return 3;
    else if (type == "AP") return 2;
    else if (type == "IB") return 1;
    else return 0; // other
  };

  // act > sat > preact > psat > ap > ib > other
  if (getTypeLevel(a.type) !== getTypeLevel(b.type)) {
    return getTypeLevel(b.type) - getTypeLevel(a.type);
  }

  // sort by score (higher > lower)
  if (a.score !== b.score) {
    return b.score - a.score;
  }

  // sort by year (later > earlier)
  if (a.year !== b.year) {
    return b.year - a.year;
  }

  // sort by month (later > earlier)
  if (a.month !== b.month) {
    return monthNumber(b.month) - monthNumber(a.month);
  }

  // sort alphabetically
  return a.subType.localeCompare(b.subType);
}

export default function GroupElem({
  group,
  setActiveGroup,
  setActiveTest,
  setGroup,
  setAddTestVisible,
  setEditTestVisible,
}: {
  group: Group;
  setActiveGroup: Dispatch<SetStateAction<Group | null>>;
  setActiveTest: Dispatch<SetStateAction<Test | null>>;
  setGroup: (group: Group) => void;
  setAddTestVisible: Dispatch<SetStateAction<boolean>>;
  setEditTestVisible: Dispatch<SetStateAction<boolean>>;
}) {
  const [bestSAT, setBestSAT] = useState(0);
  const [bestACT, setBestACT] = useState(0);
  const [favoredTest, setFavoredTest] = useState(0);

  useEffect(() => {
    if (!group.tests || Object.keys(group.tests).length == 0) {
      setBestSAT(-1);
      setBestACT(-1);
      setFavoredTest(-1);
      return;
    }

    // find highest test
    const findFavoredTest = (satScore: number, actScore: number) => {
      if (satScore == -1 || actScore == -1) return -1;
      // returns 0 if SAT is favored, 1 if ACT is favored
      let convertedACT =
        0.000047 * actScore ** 5 -
        0.0047 * actScore ** 4 +
        0.1955 * actScore ** 3 -
        4.61 * actScore ** 2 +
        98.3 * actScore -
        45.8;
      // equation generated by chatgpt based on data from https://compassprep.com/concordance-and-conversion-sat-and-act-scores/

      if (satScore < 550 && actScore < 8) return 0;
      else if (satScore > convertedACT) return 0;
      else if (satScore < convertedACT) return 1;
      else return -1;
    };

    let allSATs = [] as number[];
    let allACTs = [] as number[];

    if (group.tests && Object.keys(group.tests).length > 0) {
      for (const test of Object.values(group.tests)) {
        if (test.type == "SAT") allSATs.push(test.score);
        else if (test.type == "ACT") allACTs.push(test.score);
      }

      let highestSAT = allSATs[indexOfGreatestNumber(allSATs)];
      let highestACT = allACTs[indexOfGreatestNumber(allACTs)];
      setBestSAT(highestSAT);
      setBestACT(highestACT);
      setFavoredTest(findFavoredTest(highestSAT || -1, highestACT || -1));
      console.log(findFavoredTest(highestSAT || -1, highestACT || -1));
    }
  }, [group.tests]);

  return (
    <div>
      <div className="font-medium px-4">
        <h2 className="text-lg font-Calistoga">Tests</h2>
        <div className="block mb-3">
          <ListAttribute
            name={favoredTest ? "Favor ACT" : "Favor SAT"}
            calculation={-1}
            decimals={0}
            classN={favoredTest == -1 ? "hidden" : ""}
          />
          <ListAttribute
            name="ACT"
            calculation={bestACT}
            decimals={0}
            classN={bestACT < 0 ? "hidden" : ""}
          />
          <ListAttribute
            name="SAT"
            calculation={bestSAT}
            decimals={0}
            classN={bestSAT < 0 ? "hidden" : ""}
          />
        </div>
      </div>
      <ul>
        {(Object.values(group?.tests || {}) as Test[])
          .sort(sortTests)
          .map((test) => (
            <TestElem
              key={test.uuid}
              test={test}
              onEdit={() => {
                setActiveTest(test);
                setActiveGroup(group);
                setEditTestVisible(true);
              }}
              onTrash={() => {
                if (
                  confirm("Are you sure you want to remove " + test.name + "?")
                ) {
                  const newGroup = JSON.parse(JSON.stringify(group)) as Group;

                  if (newGroup.tests && test.uuid in newGroup.tests) {
                    delete newGroup.tests[test.uuid];
                  }

                  setGroup(newGroup);
                }
              }}
            />
          ))}
      </ul>
      <button
        className="text-gray-100 dark:text-gray-900 border-2 rounded-md bg-emerald-600 hover:bg-emerald-700 active:bg-emerald-800 border-transparent w-full text-left transition px-3 py-2"
        onClick={() => {
          setActiveGroup(group);
          setAddTestVisible(true);
        }}
      >
        <FontAwesomeIcon icon={faPlus} className="mr-1" />
        Add a test
      </button>
    </div>
  );
}
